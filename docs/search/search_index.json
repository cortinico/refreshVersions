{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Gradle refreshVersions \u00b6 Life is too short to google for dependencies and versions Why refreshVersions? \u00b6 Gradle multi-module projects are on the rise. At the same time, library vendors publish very modularized artifacts: On Android, the big fat support libraries are dead, and their replacement, AndroidX , contains more than 200 different dependencies, grouped in over 70 groups, each having its own version. (AndroidX is only a part of first-party dependencies for Android projects, and third party dependencies can add up.) On the server, many frameworks or library suites offer a high number of artifacts. That applies to Ktor, Spring, http4k and others. Again, that\u2019s not even counting third party dependencies. Both trends come with great technical benefits. However, they also make it much more tedious to find where to add and update your dependencies in all those build.gradle[.kts] files! We saw this make developers update the dependencies less and less often, effectively leading to legacy accumulation (a form of technical debt), or even projects abandon. Yes, that\u2019s sad. Can we have our cake and eat it? We firmly believe that yes, we can have the benefits of modularization without the hell of dependency management . So what does gradle refreshVersions ? Centralize your dependencies in a proper file format \u00b6 Everyone who uses Gradle in a multi-modules environment has looked for a way to centralize all dependencies in one place. And there are solutions for that. Too many solutions in fact. Some put their versions in a variable val retrofitVersion = 2.9.0 , others in rootproject.ext , others in a libraries.gradle file, others still in buildSrc/src/main/Versions.kt , and the list goes on and on! A problem common to all those solutions is that they store the versions in a turing-complete programming language (Groovy or Kotlin). Then people try to hack together regular expressions to read or modify those files. We think this is wrong! Instead, gradle refreshVersions stores all the versions in one place in a proper file format: Java Properties, like gradle.properties . Just like npm\u2019s package.json , Maven\u2019s pom.xml , this file can be easily read and written by a computer program. Yes to better tooling! No Magic! \u00b6 You wonder how this works? No black magic involved, we leverage Gradle public APIs that are designed to edit declared dependencies ( Configuration.withDependencies , and PluginManagement.resolutionStrategy ), and we edit the versions constraints there. The rest is just a set of conventions. Consider the example below: Dependency notation Version key org.gradle:gradle-hello-world-plugin:_ version.org.gradle..gradle-hello-world-plugin com.squareup.retrofit2:retrofit:_ version.retrofit com.squareup.retrofit2:retrofit-adapter-xxx:_ version.retrofit plugin with id \u201ccom.squareup.sqldelight\u201d plugin.com.squareup.sqldelight gradle refreshVersions works with an opt-in mechanism. It only manages dependencies where the version is set to be a placeholder, more specifically the underscore _ , which, akin to Kotlin, here means that the version is not used, being instead set in the versions.properties file. gradle refreshVersions has a system of rules that here, allows to set all Retrofit dependencies with the same version key version.retrofit , keeping things DRY. Look up for updates automatically \u00b6 With this infrastructure being in place, the major feature of gradle refreshVersions is like its name suggests: It will look up for all available updates of the dependencies used in the project. Simply run $ ./gradlew refreshVersions and you will see the available updates as comments : Why as comment? Because while googling manually for available updates is a monkey job that is best done by a computer program, while deciding whether to upgrade or not is your job as a programmer. Read more: Update Dependencies It\u2019s fast! \u00b6 The Kotlin Libraries Playground contains about 80 dependencies, and counting. How long would it take to search for all available updates? Well, if you do it manually: enough to hate your life . With the gradle-versions-plugin it will take about 2 minutes. With refreshVersions, you are done in 10 seconds ! See benchmarks here. Add dependencies quickly! \u00b6 gradle refreshVersions provides read-to-use organized dependency notations for popular libraries. Read more: Add Dependencies Requirements \u00b6 Gradle 6.3+ IntelliJ IDEA or Android Studio Try it out with zero setup! \u00b6 The simplest way to try out gradle refreshVersions is with our official sample, the Kotlin libraries Playground ! Everything is pre-configured here, so just open the project in IntelliJ and start adding and upgrading dependencies. Warning: You may also learn a ton of things about Kotlin libraries in the process! Funding \u2764\ufe0f \u00b6 We hope this open source project saves you a lot of time! It is maintained by its authors, Jean-Michel Fayard and Louis CAD. You can buy us more time by becoming our sponsors: \ud83d\udc9d Louis CAD GitHub Sponsors page \ud83d\udc9d Jean-Michel GitHub Sponsors page We\u2019re very grateful to you and our existing sponsors , thank you! \u2764\ufe0f\u2764\ufe0f Contributing \u00b6 This project is under the MIT License. Explain your use case and start the discussion before your submit a pull-request CONTRIBUTING describes the process for submitting pull requests.","title":"Overview"},{"location":"#gradle-refreshversions","text":"Life is too short to google for dependencies and versions","title":"Gradle refreshVersions"},{"location":"#why-refreshversions","text":"Gradle multi-module projects are on the rise. At the same time, library vendors publish very modularized artifacts: On Android, the big fat support libraries are dead, and their replacement, AndroidX , contains more than 200 different dependencies, grouped in over 70 groups, each having its own version. (AndroidX is only a part of first-party dependencies for Android projects, and third party dependencies can add up.) On the server, many frameworks or library suites offer a high number of artifacts. That applies to Ktor, Spring, http4k and others. Again, that\u2019s not even counting third party dependencies. Both trends come with great technical benefits. However, they also make it much more tedious to find where to add and update your dependencies in all those build.gradle[.kts] files! We saw this make developers update the dependencies less and less often, effectively leading to legacy accumulation (a form of technical debt), or even projects abandon. Yes, that\u2019s sad. Can we have our cake and eat it? We firmly believe that yes, we can have the benefits of modularization without the hell of dependency management . So what does gradle refreshVersions ?","title":"Why refreshVersions?"},{"location":"#centralize-your-dependencies-in-a-proper-file-format","text":"Everyone who uses Gradle in a multi-modules environment has looked for a way to centralize all dependencies in one place. And there are solutions for that. Too many solutions in fact. Some put their versions in a variable val retrofitVersion = 2.9.0 , others in rootproject.ext , others in a libraries.gradle file, others still in buildSrc/src/main/Versions.kt , and the list goes on and on! A problem common to all those solutions is that they store the versions in a turing-complete programming language (Groovy or Kotlin). Then people try to hack together regular expressions to read or modify those files. We think this is wrong! Instead, gradle refreshVersions stores all the versions in one place in a proper file format: Java Properties, like gradle.properties . Just like npm\u2019s package.json , Maven\u2019s pom.xml , this file can be easily read and written by a computer program. Yes to better tooling!","title":"Centralize your dependencies in a proper file format"},{"location":"#no-magic","text":"You wonder how this works? No black magic involved, we leverage Gradle public APIs that are designed to edit declared dependencies ( Configuration.withDependencies , and PluginManagement.resolutionStrategy ), and we edit the versions constraints there. The rest is just a set of conventions. Consider the example below: Dependency notation Version key org.gradle:gradle-hello-world-plugin:_ version.org.gradle..gradle-hello-world-plugin com.squareup.retrofit2:retrofit:_ version.retrofit com.squareup.retrofit2:retrofit-adapter-xxx:_ version.retrofit plugin with id \u201ccom.squareup.sqldelight\u201d plugin.com.squareup.sqldelight gradle refreshVersions works with an opt-in mechanism. It only manages dependencies where the version is set to be a placeholder, more specifically the underscore _ , which, akin to Kotlin, here means that the version is not used, being instead set in the versions.properties file. gradle refreshVersions has a system of rules that here, allows to set all Retrofit dependencies with the same version key version.retrofit , keeping things DRY.","title":"No Magic!"},{"location":"#look-up-for-updates-automatically","text":"With this infrastructure being in place, the major feature of gradle refreshVersions is like its name suggests: It will look up for all available updates of the dependencies used in the project. Simply run $ ./gradlew refreshVersions and you will see the available updates as comments : Why as comment? Because while googling manually for available updates is a monkey job that is best done by a computer program, while deciding whether to upgrade or not is your job as a programmer. Read more: Update Dependencies","title":"Look up for updates automatically"},{"location":"#its-fast","text":"The Kotlin Libraries Playground contains about 80 dependencies, and counting. How long would it take to search for all available updates? Well, if you do it manually: enough to hate your life . With the gradle-versions-plugin it will take about 2 minutes. With refreshVersions, you are done in 10 seconds ! See benchmarks here.","title":"It's fast!"},{"location":"#add-dependencies-quickly","text":"gradle refreshVersions provides read-to-use organized dependency notations for popular libraries. Read more: Add Dependencies","title":"Add dependencies quickly!"},{"location":"#requirements","text":"Gradle 6.3+ IntelliJ IDEA or Android Studio","title":"Requirements"},{"location":"#try-it-out-with-zero-setup","text":"The simplest way to try out gradle refreshVersions is with our official sample, the Kotlin libraries Playground ! Everything is pre-configured here, so just open the project in IntelliJ and start adding and upgrading dependencies. Warning: You may also learn a ton of things about Kotlin libraries in the process!","title":"Try it out with zero setup!"},{"location":"#funding","text":"We hope this open source project saves you a lot of time! It is maintained by its authors, Jean-Michel Fayard and Louis CAD. You can buy us more time by becoming our sponsors: \ud83d\udc9d Louis CAD GitHub Sponsors page \ud83d\udc9d Jean-Michel GitHub Sponsors page We\u2019re very grateful to you and our existing sponsors , thank you! \u2764\ufe0f\u2764\ufe0f","title":"Funding \u2764\ufe0f"},{"location":"#contributing","text":"This project is under the MIT License. Explain your use case and start the discussion before your submit a pull-request CONTRIBUTING describes the process for submitting pull requests.","title":"Contributing"},{"location":"add-dependencies/","text":"Add dependencies \u00b6 Use built-in dependency notations \u00b6 refreshVersions provides read-to-use organized dependency notations for select popular libraries of the following ecosystems: Kotlin Multiplatform Kotlin/JVM Android That doesn\u2019t prevent you from using refreshVersions in a Gradle project that is not using Kotlin or is not an Android project. You can use them in any build.gradle or build.gradle.kts file. Here\u2019s an example of how it looks like in the IDE: No imports needed. Autocomplete in IDE for easy discoverability. You can see all the dependency objects in this directory . Wait, what version are those dependencies using? \u00b6 All these dependency notations specify their version as the version placeholder ( _ ), so refreshVersions can replace them seamlessly with the corresponding value defined in the versions.properties file, via Gradle APIs. After adding a dependency that doesn\u2019t have its version specified in the versions.properties file yet, refreshVersions will edit it and put the most stable recent version in it on the next Gradle sync (or any other Gradle run). It will also put any less stable versions as comments, allowing you to quickly upgrade if needed. Add Gradle plugins \u00b6 This section doesn\u2019t apply to plugins that are configured in a buildscript block (since these have their versions configured like regular dependencies), but only to those that are configured solely with a plugin id. To add such a plugin, do as usual, but do not specify the version in the build.gradle or build.gradle.kts file. Instead, set it up like so in the versions.properties file: versions.properties plugin.com.apollographql.apollo = 2.4.1 plugin.com.squareup.sqldelight = 1.4.3 Then you can omit the plugin version in all build.gradle(.kts) of your project: some-module/build.gradle.kts some-module/build.gradle plugins { id 'com.squareup.sqldelight' id 'com.apollographql.apollo' } As you see, the convention is pretty simple. The key is the id of the plugin, prefixed by plugin. : plugin.some.plugin.id sets the version of the plugin of id some.plugin.id . Non-built-in dependency notations \u00b6 Use gradle buildSrcVersions (WIP) \u00b6 Yet another approach to managing dependencies is to use the Gradle buildSrc module, and to automatically generate a file Libs.kt that contains all the dependencies applied to your build: buildSrc/src/main/kotlin/Libs.kt /** * Generated by `$ ./gradlew buildSrcVersions` */ object Libs { const val guava : String = \"com.google.guava:guava:_\" const val guice : String = \"com.google.inject:guice:_\" } Because this file used the placeholder version _ , it is compatible with gradle refreshVersions! This feature is not done yet. If you think we should prioritze it, please vote for this issue with a \ud83d\udc4d and subscribe to it. Use Package Search from JetBrains \u00b6 JetBrains offers the plugin Package Search . Package Search provides a nice UX to add a dependency: Can you use it with refreshVersions? Sure, just use the version placeholder ( _ ). Use the libraries.gradle pattern \u00b6 An older approach to centralize dependencies is to have a libraries.gradle file: libraries.gradle ext . libraries = [ // Groovy map literal spring_core: \"org.springframework:spring-core:3.1\" , junit: \"junit:junit:4.10\" ] some-module/build.gradle apply ( from = \"../libraries.gradle\" ) dependencies { compile libraries . spring_core testCompile libraries . junit } Does that work with refreshVersions too? Yes, just use the version placeholder ( _ ): libraries.gradle ext.libraries = [ // Groovy map literal - spring_core: \"org.springframework:spring-core:3.1\", + spring_core: \"org.springframework:spring-core:_\", - junit: \"junit:junit:4.10\" + junit: \"junit:junit:_\" ]","title":"Add Dependencies"},{"location":"add-dependencies/#add-dependencies","text":"","title":"Add dependencies"},{"location":"add-dependencies/#use-built-in-dependency-notations","text":"refreshVersions provides read-to-use organized dependency notations for select popular libraries of the following ecosystems: Kotlin Multiplatform Kotlin/JVM Android That doesn\u2019t prevent you from using refreshVersions in a Gradle project that is not using Kotlin or is not an Android project. You can use them in any build.gradle or build.gradle.kts file. Here\u2019s an example of how it looks like in the IDE: No imports needed. Autocomplete in IDE for easy discoverability. You can see all the dependency objects in this directory .","title":"Use built-in dependency notations"},{"location":"add-dependencies/#wait-what-version-are-those-dependencies-using","text":"All these dependency notations specify their version as the version placeholder ( _ ), so refreshVersions can replace them seamlessly with the corresponding value defined in the versions.properties file, via Gradle APIs. After adding a dependency that doesn\u2019t have its version specified in the versions.properties file yet, refreshVersions will edit it and put the most stable recent version in it on the next Gradle sync (or any other Gradle run). It will also put any less stable versions as comments, allowing you to quickly upgrade if needed.","title":"Wait, what version are those dependencies using?"},{"location":"add-dependencies/#add-gradle-plugins","text":"This section doesn\u2019t apply to plugins that are configured in a buildscript block (since these have their versions configured like regular dependencies), but only to those that are configured solely with a plugin id. To add such a plugin, do as usual, but do not specify the version in the build.gradle or build.gradle.kts file. Instead, set it up like so in the versions.properties file: versions.properties plugin.com.apollographql.apollo = 2.4.1 plugin.com.squareup.sqldelight = 1.4.3 Then you can omit the plugin version in all build.gradle(.kts) of your project: some-module/build.gradle.kts some-module/build.gradle plugins { id 'com.squareup.sqldelight' id 'com.apollographql.apollo' } As you see, the convention is pretty simple. The key is the id of the plugin, prefixed by plugin. : plugin.some.plugin.id sets the version of the plugin of id some.plugin.id .","title":"Add Gradle plugins"},{"location":"add-dependencies/#non-built-in-dependency-notations","text":"","title":"Non-built-in dependency notations"},{"location":"add-dependencies/#use-gradle-buildsrcversions-wip","text":"Yet another approach to managing dependencies is to use the Gradle buildSrc module, and to automatically generate a file Libs.kt that contains all the dependencies applied to your build: buildSrc/src/main/kotlin/Libs.kt /** * Generated by `$ ./gradlew buildSrcVersions` */ object Libs { const val guava : String = \"com.google.guava:guava:_\" const val guice : String = \"com.google.inject:guice:_\" } Because this file used the placeholder version _ , it is compatible with gradle refreshVersions! This feature is not done yet. If you think we should prioritze it, please vote for this issue with a \ud83d\udc4d and subscribe to it.","title":"Use gradle buildSrcVersions (WIP)"},{"location":"add-dependencies/#use-package-search-from-jetbrains","text":"JetBrains offers the plugin Package Search . Package Search provides a nice UX to add a dependency: Can you use it with refreshVersions? Sure, just use the version placeholder ( _ ).","title":"Use Package Search from JetBrains"},{"location":"add-dependencies/#use-the-librariesgradle-pattern","text":"An older approach to centralize dependencies is to have a libraries.gradle file: libraries.gradle ext . libraries = [ // Groovy map literal spring_core: \"org.springframework:spring-core:3.1\" , junit: \"junit:junit:4.10\" ] some-module/build.gradle apply ( from = \"../libraries.gradle\" ) dependencies { compile libraries . spring_core testCompile libraries . junit } Does that work with refreshVersions too? Yes, just use the version placeholder ( _ ): libraries.gradle ext.libraries = [ // Groovy map literal - spring_core: \"org.springframework:spring-core:3.1\", + spring_core: \"org.springframework:spring-core:_\", - junit: \"junit:junit:4.10\" + junit: \"junit:junit:_\" ]","title":"Use the libraries.gradle pattern"},{"location":"faq/","text":"FAQ \u00b6 TK","title":"FAQ"},{"location":"faq/#faq","text":"TK","title":"FAQ"},{"location":"gradle-buildsrcversions/","text":"The buildSrc module \u00b6 The buildSrc is a Gradle module where you can write Kotlin code like usual (with full tooling support). That code is then be available to all your build files - not your final application. One cool thing you can do with it is to replace those libraries.gradle files we used to write: buildSrc/src/main/kotlin/Libs.kt object Libs { const val okhttp = \"com.squareup.okhttp3:okhttp:\" + Versions . okhttp const val okio = \"com.squareup.okio:okio:\" + Versions . okio } buildSrc/src/main/kotlin/Versions.kt object Versions { const val okhttp = \"3.12.1\" const val okio = \"2.0.0\" } The crucial difference was that IntelliJ IDEA and Android Studio have good support for calling it from build.gradle[.kts] Finally the IDE tooling we deserve: auto-completion jumping to definition \u2026 \u201cgradle buildSrcVersions\u201d is dead\u2026 \u00b6 The ancestor of the plugin refreshVersions was a plugin called buildSrcVersions . What it did was to auto-generate the buildSrc/.../{Libs,Versions}.kt files above! $ ./gradlew buildSrcVersions > Task :dependencyUpdates > Task :buildSrcVersions new file: buildSrc/build.gradle.kts new file: buildSrc/.gitignore new file: buildSrc/src/main/kotlin/Libs.kt new file: buildSrc/src/main/kotlin/Versions.kt .. long live \u201cgradle buildSrcLibs\u201d! \u00b6 The Versions.kt file was replaced by a technically better solution, the versions.properties file. But the Libs.kt file has still pretty good use cases, like a project with lots of Gradle modules written in Groovy. That\u2019s why the plugin refreshVersions still contains a task :buildSrcVersions \u2013 which is just an alias for the better named task :buildSrcLibs . Use it like this: $ ./gradlew buildSrcLibs > Task :buildSrcLibs new file: versions.properties new file: buildSrc/src/main/kotlin/Libs.kt The task generates what you expect: versions.properties version.okhttp = 3.12.1 version.okio = 2.0.0 buildSrc/src/main/kotlin/Libs.kt object Libs { const val okhttp = \"com.squareup.okhttp3:okhttp:_\" const val okio = \"com.squareup.okio:okio:_\" } The constant generated in Libs.kt are the same as they was in the plugin buildSrcVersions . This makes updating to refreshVersions pretty straightforward. Replace your dependencies \u00b6 Sync your Gradle build. You can now start to replace your magic strings with the properties available in Libs.kt Update dependencies \u00b6 You can still automatically look for updates, but this is now done with the task :refreshVersions and editing the file versions.properties $ gradle refreshVersions Read more: Update dependencies .","title":"Gradle buildsrcversions"},{"location":"gradle-buildsrcversions/#the-buildsrc-module","text":"The buildSrc is a Gradle module where you can write Kotlin code like usual (with full tooling support). That code is then be available to all your build files - not your final application. One cool thing you can do with it is to replace those libraries.gradle files we used to write: buildSrc/src/main/kotlin/Libs.kt object Libs { const val okhttp = \"com.squareup.okhttp3:okhttp:\" + Versions . okhttp const val okio = \"com.squareup.okio:okio:\" + Versions . okio } buildSrc/src/main/kotlin/Versions.kt object Versions { const val okhttp = \"3.12.1\" const val okio = \"2.0.0\" } The crucial difference was that IntelliJ IDEA and Android Studio have good support for calling it from build.gradle[.kts] Finally the IDE tooling we deserve: auto-completion jumping to definition \u2026","title":"The buildSrc module"},{"location":"gradle-buildsrcversions/#gradle-buildsrcversions-is-dead","text":"The ancestor of the plugin refreshVersions was a plugin called buildSrcVersions . What it did was to auto-generate the buildSrc/.../{Libs,Versions}.kt files above! $ ./gradlew buildSrcVersions > Task :dependencyUpdates > Task :buildSrcVersions new file: buildSrc/build.gradle.kts new file: buildSrc/.gitignore new file: buildSrc/src/main/kotlin/Libs.kt new file: buildSrc/src/main/kotlin/Versions.kt","title":"\"gradle buildSrcVersions\" is dead..."},{"location":"gradle-buildsrcversions/#long-live-gradle-buildsrclibs","text":"The Versions.kt file was replaced by a technically better solution, the versions.properties file. But the Libs.kt file has still pretty good use cases, like a project with lots of Gradle modules written in Groovy. That\u2019s why the plugin refreshVersions still contains a task :buildSrcVersions \u2013 which is just an alias for the better named task :buildSrcLibs . Use it like this: $ ./gradlew buildSrcLibs > Task :buildSrcLibs new file: versions.properties new file: buildSrc/src/main/kotlin/Libs.kt The task generates what you expect: versions.properties version.okhttp = 3.12.1 version.okio = 2.0.0 buildSrc/src/main/kotlin/Libs.kt object Libs { const val okhttp = \"com.squareup.okhttp3:okhttp:_\" const val okio = \"com.squareup.okio:okio:_\" } The constant generated in Libs.kt are the same as they was in the plugin buildSrcVersions . This makes updating to refreshVersions pretty straightforward.","title":".. long live \"gradle buildSrcLibs\"!"},{"location":"gradle-buildsrcversions/#replace-your-dependencies","text":"Sync your Gradle build. You can now start to replace your magic strings with the properties available in Libs.kt","title":"Replace your dependencies"},{"location":"gradle-buildsrcversions/#update-dependencies","text":"You can still automatically look for updates, but this is now done with the task :refreshVersions and editing the file versions.properties $ gradle refreshVersions Read more: Update dependencies .","title":"Update dependencies"},{"location":"migration/","text":"Migration \u00b6 You can migrate existing dependencies, so they use the version placeholder in order to have their available updates found by refreshVersions and easily applied. We provide an experimental interactive Gradle task made for migration. To use it, run the following command and follow the instructions : ./gradlew migrateToRefreshVersionsDependenciesConstants --console = plain About the experimental status \u00b6 That migration task is safe to use (except if you have different modules with different versions of the same dependency family), but its UX has a few known issues. Here\u2019s the improvement plan: Ergonomics (Don\u2019t require to type a full word to validate migration of a single dependency) Keep track of what has been migrated already to not show out of sync hardcoded dependencies count Automatically replace dependency notations in the build files when possible safely Have better rules to ignore dependencies added by plugins (e.g. \u201ckotlin-android-extensions\u201d plugin) Its name (remove lengthy migrateToRefreshVersionsDependenciesConstants and have a --migrate flag to refreshVersions redirect to it instead) These improvements are planned for the 1.0 release. You can follow this issue to track when it is resolved exactly, and you can also vote for it with a \ud83d\udc4d.","title":"Migration"},{"location":"migration/#migration","text":"You can migrate existing dependencies, so they use the version placeholder in order to have their available updates found by refreshVersions and easily applied. We provide an experimental interactive Gradle task made for migration. To use it, run the following command and follow the instructions : ./gradlew migrateToRefreshVersionsDependenciesConstants --console = plain","title":"Migration"},{"location":"migration/#about-the-experimental-status","text":"That migration task is safe to use (except if you have different modules with different versions of the same dependency family), but its UX has a few known issues. Here\u2019s the improvement plan: Ergonomics (Don\u2019t require to type a full word to validate migration of a single dependency) Keep track of what has been migrated already to not show out of sync hardcoded dependencies count Automatically replace dependency notations in the build files when possible safely Have better rules to ignore dependencies added by plugins (e.g. \u201ckotlin-android-extensions\u201d plugin) Its name (remove lengthy migrateToRefreshVersionsDependenciesConstants and have a --migrate flag to refreshVersions redirect to it instead) These improvements are planned for the 1.0 release. You can follow this issue to track when it is resolved exactly, and you can also vote for it with a \ud83d\udc4d.","title":"About the experimental status"},{"location":"setup/","text":"Setup \u00b6 This guide will help you set up refreshVersions in a Gradle project. Update Gradle (if needed) \u00b6 Only Gradle 6.3+ is supported at the moment, because there were a lot of changes in dependencies management in Gradle 6, and other compatibility concerns. It also allows for a simpler setup for plugins for example. Updating Gradle is anyway usually a good idea. You get fewer bugs, more features, and faster builds. Run this command to update: ./gradlew wrapper --gradle-version 6 .7 You should also try to update the Gradle plugins present in your build to the latest version. For example on an Android project, do update the version of the Gradle Android Plugin. The Gradle documentation has detailed migration guide if you are stuck: From Gradle 6+: https://docs.gradle.org/current/userguide/upgrading_version_6.html From Gradle 5.x: https://docs.gradle.org/current/userguide/upgrading_version_5.html From Gradle 4.x: https://docs.gradle.org/current/userguide/upgrading_version_4.html About Gradle\u2019s Settings file \u00b6 For refreshVersions to be able to work for all the dependencies in your project, including for the ones in the buildscript \u2018s classpath , it needs to be setup in the Gradle settings. A Gradle project has a Settings file called settings.gradle or settings.gradle.kts where you must respect a certain order (otherwise, the build breaks). The order is: imports, if any. The pluginManagement block, if any. The buildscript block, if any. (We will use it) The plugins block, if any settings plugins are applied. Logic for Gradle settings (any other code). See the example snippet below: import com.example.something // Imports at the top, as usual. pluginManagement {} // Optional buildscript { // We will setup refreshVersions here, see below. } plugins {} // Optional // Then you can have other code after the blocks above, // we will bootstrap refreshVersions here. rootProject . name = \"My Project\" // Optional, defaults to parent dir's name. include ( \":app\" ) // If the project has modules/subprojects to declare. Bootstrap refreshVersions \u00b6 Here is how to configure gradle refreshVersions: settings.gradle.kts import de.fayard.refreshVersions.bootstrapRefreshVersions buildscript { repositories { gradlePluginPortal () } dependencies . classpath ( \"de.fayard.refreshVersions:refreshVersions:0.9.7\" ) } bootstrapRefreshVersions () settings.gradle import de.fayard.refreshVersions.RefreshVersionsSetup buildscript { repositories { gradlePluginPortal () } dependencies . classpath ( \"de.fayard.refreshVersions:refreshVersions:0.9.7\" ) } RefreshVersionsSetup . bootstrap ( settings ) If you upgrade from the plugin buildSrcVersions \u00b6 Before refreshVersions, there was the plugin buildSrcVersions If your project is using it, remove all its configuration from the top build.gradle[.kts] file build.gradle.kts -plugins { - id(\"de.fayard.buildSrcVersions\") version \"0.3.2\" -} -buildSrcVersions { - someOption = \"somevalue\" -} The task buildSrcVersions is still available. Read more: gradle buildSrcVersions . If you have a buildSrc module \u00b6 If you use the buildSrc module and have dependencies declared in the buildSrc/build.gradle[.kts] file, you probably want to use refreshVersions there as well. For that, an extra special setup is required. buildSrc/settings.gradle.kts import de.fayard.refreshVersions.bootstrapRefreshVersionsForBuildSrc buildscript { repositories { gradlePluginPortal () } dependencies . classpath ( \"de.fayard.refreshVersions:refreshVersions:0.9.7\" ) } bootstrapRefreshVersionsForBuildSrc () buildSrc/settings.gradle import de.fayard.refreshVersions.RefreshVersionsSetup buildscript { repositories { gradlePluginPortal () } dependencies . classpath ( \"de.fayard.refreshVersions:refreshVersions:0.9.7\" ) } RefreshVersionsSetup . bootstrapForBuildSrc ( settings ) If you have a composite/included build \u00b6 Sharing used versions with included builds is not supported at the moment. If you need/want this feature, please vote with a \ud83d\udc4d on this issue , subscribe to it, and tell us about your use case, to help us prioritize. If you want to use a development version \u00b6 To use a development version (for example to test an unreleased new feature), you need to find the published development versions by searching in the recent commits on the develop branch (they start with \u201cDev version\u201d). You also need to add the maven repository https://dl.bintray.com/jmfayard/maven as shown below: settings.gradle.kts import de.fayard.refreshVersions.bootstrapRefreshVersions buildscript { repositories { gradlePluginPortal () maven ( \"https://dl.bintray.com/jmfayard/maven\" ) } dependencies . classpath ( \"de.fayard.refreshVersions:refreshVersions:0.9.7-dev-001\" ) } bootstrapRefreshVersions () settings.gradle import de.fayard.refreshVersions.RefreshVersionsSetup buildscript { repositories { gradlePluginPortal () maven { url 'https://dl.bintray.com/jmfayard/maven' } } dependencies . classpath ( \"de.fayard.refreshVersions:refreshVersions:0.9.7-dev-001\" ) } RefreshVersionsSetup . bootstrap ( settings ) Next steps \u00b6 You did it! refreshVersions is now properly setup. Now, you might want to: Migrate/opt-in existing dependency declarations , so the refreshVersions task can find available updates for you. Add new dependencies . Update dependencies .","title":"Setup"},{"location":"setup/#setup","text":"This guide will help you set up refreshVersions in a Gradle project.","title":"Setup"},{"location":"setup/#update-gradle-if-needed","text":"Only Gradle 6.3+ is supported at the moment, because there were a lot of changes in dependencies management in Gradle 6, and other compatibility concerns. It also allows for a simpler setup for plugins for example. Updating Gradle is anyway usually a good idea. You get fewer bugs, more features, and faster builds. Run this command to update: ./gradlew wrapper --gradle-version 6 .7 You should also try to update the Gradle plugins present in your build to the latest version. For example on an Android project, do update the version of the Gradle Android Plugin. The Gradle documentation has detailed migration guide if you are stuck: From Gradle 6+: https://docs.gradle.org/current/userguide/upgrading_version_6.html From Gradle 5.x: https://docs.gradle.org/current/userguide/upgrading_version_5.html From Gradle 4.x: https://docs.gradle.org/current/userguide/upgrading_version_4.html","title":"Update Gradle (if needed)"},{"location":"setup/#about-gradles-settings-file","text":"For refreshVersions to be able to work for all the dependencies in your project, including for the ones in the buildscript \u2018s classpath , it needs to be setup in the Gradle settings. A Gradle project has a Settings file called settings.gradle or settings.gradle.kts where you must respect a certain order (otherwise, the build breaks). The order is: imports, if any. The pluginManagement block, if any. The buildscript block, if any. (We will use it) The plugins block, if any settings plugins are applied. Logic for Gradle settings (any other code). See the example snippet below: import com.example.something // Imports at the top, as usual. pluginManagement {} // Optional buildscript { // We will setup refreshVersions here, see below. } plugins {} // Optional // Then you can have other code after the blocks above, // we will bootstrap refreshVersions here. rootProject . name = \"My Project\" // Optional, defaults to parent dir's name. include ( \":app\" ) // If the project has modules/subprojects to declare.","title":"About Gradle's Settings file"},{"location":"setup/#bootstrap-refreshversions","text":"Here is how to configure gradle refreshVersions: settings.gradle.kts import de.fayard.refreshVersions.bootstrapRefreshVersions buildscript { repositories { gradlePluginPortal () } dependencies . classpath ( \"de.fayard.refreshVersions:refreshVersions:0.9.7\" ) } bootstrapRefreshVersions () settings.gradle import de.fayard.refreshVersions.RefreshVersionsSetup buildscript { repositories { gradlePluginPortal () } dependencies . classpath ( \"de.fayard.refreshVersions:refreshVersions:0.9.7\" ) } RefreshVersionsSetup . bootstrap ( settings )","title":"Bootstrap refreshVersions"},{"location":"setup/#if-you-upgrade-from-the-plugin-buildsrcversions","text":"Before refreshVersions, there was the plugin buildSrcVersions If your project is using it, remove all its configuration from the top build.gradle[.kts] file build.gradle.kts -plugins { - id(\"de.fayard.buildSrcVersions\") version \"0.3.2\" -} -buildSrcVersions { - someOption = \"somevalue\" -} The task buildSrcVersions is still available. Read more: gradle buildSrcVersions .","title":"If you upgrade from the plugin buildSrcVersions"},{"location":"setup/#if-you-have-a-buildsrc-module","text":"If you use the buildSrc module and have dependencies declared in the buildSrc/build.gradle[.kts] file, you probably want to use refreshVersions there as well. For that, an extra special setup is required. buildSrc/settings.gradle.kts import de.fayard.refreshVersions.bootstrapRefreshVersionsForBuildSrc buildscript { repositories { gradlePluginPortal () } dependencies . classpath ( \"de.fayard.refreshVersions:refreshVersions:0.9.7\" ) } bootstrapRefreshVersionsForBuildSrc () buildSrc/settings.gradle import de.fayard.refreshVersions.RefreshVersionsSetup buildscript { repositories { gradlePluginPortal () } dependencies . classpath ( \"de.fayard.refreshVersions:refreshVersions:0.9.7\" ) } RefreshVersionsSetup . bootstrapForBuildSrc ( settings )","title":"If you have a buildSrc module"},{"location":"setup/#if-you-have-a-compositeincluded-build","text":"Sharing used versions with included builds is not supported at the moment. If you need/want this feature, please vote with a \ud83d\udc4d on this issue , subscribe to it, and tell us about your use case, to help us prioritize.","title":"If you have a composite/included build"},{"location":"setup/#if-you-want-to-use-a-development-version","text":"To use a development version (for example to test an unreleased new feature), you need to find the published development versions by searching in the recent commits on the develop branch (they start with \u201cDev version\u201d). You also need to add the maven repository https://dl.bintray.com/jmfayard/maven as shown below: settings.gradle.kts import de.fayard.refreshVersions.bootstrapRefreshVersions buildscript { repositories { gradlePluginPortal () maven ( \"https://dl.bintray.com/jmfayard/maven\" ) } dependencies . classpath ( \"de.fayard.refreshVersions:refreshVersions:0.9.7-dev-001\" ) } bootstrapRefreshVersions () settings.gradle import de.fayard.refreshVersions.RefreshVersionsSetup buildscript { repositories { gradlePluginPortal () maven { url 'https://dl.bintray.com/jmfayard/maven' } } dependencies . classpath ( \"de.fayard.refreshVersions:refreshVersions:0.9.7-dev-001\" ) } RefreshVersionsSetup . bootstrap ( settings )","title":"If you want to use a development version"},{"location":"setup/#next-steps","text":"You did it! refreshVersions is now properly setup. Now, you might want to: Migrate/opt-in existing dependency declarations , so the refreshVersions task can find available updates for you. Add new dependencies . Update dependencies .","title":"Next steps"},{"location":"update-dependencies/","text":"Update dependencies \u00b6 The core feature is gradle refreshVersions is that it will lookup automatically for available updates for all the dependencies that it manages. This is done in three small steps: 1. Run the refreshVersions Gradle task \u00b6 Run the refreshVersions gradle task on the root project: ./gradlew refreshVersions Hint: You don\u2019t need to leave the IDE to run a Gradle task. IntelliJ has a handy action named \u201cExecute Gradle Task\u201d: Gradle refreshVersions is fast: it usually takes less than 10 seconds to execute on relatively big projects. 2. Apply the updates you want to \u00b6 Open the versions.properties file. Let say you have this initial state: After you have run the refreshVersions task, you will see the available updates as comments : Why as comments? \u00b6 Looking for available updates is certainly a job best done by a computer program (instead of you doing the monkey job of googling, clicking and scrolling for every single used dependency). However, the decision of whether to upgrade or not, when, and towards which version, is best decided by the developers responsible like you. Edit the versions.properties file \u00b6 If you decide to update, just replace the previous version with the update: If you decide to not update for now, you can leave the comments there. They will not affect your build, and will serve as a reminder to revisit upgrading these dependencies later. They also allow you to glance at how behind the dependencies are, which is a way to estimate the technical debt of the project regarding the dependencies upgrades. If you want to delete these comments, it\u2019s possible too, and it\u2019s safe. Running the refreshVersions task will bring them back (plus any newer available update). 3. Perform a Gradle sync/reload \u00b6 The file versions.properties is part of the Gradle build. Consequently, after you have edited it, you need to ensure the IDE gets the changes. The action to do it have a different name depending on the IDE: IntelliJ IDEA: Run the \u201cReload all Gradle projects\u201d action (via ctrl / cmd + shift + A ), or click the refresh arrows in the Gradle tool window Android Studio: Run the \u201cSync Project with Gradle Files\u201d action (via ctrl / cmd + shift + A ), or click the elephant + arrow icon in the toolbar. At that point, you probably want to: \u23ed Migrate deprecated symbols (if any) \ud83d\udd28 Ensure the codebase still builds properly \u2705 Ensure the tests still run properly \ud83d\udd75\ufe0f\u200d\u2640\ufe0f Do manual testing if needed \u2705 Commit when appropriate \ud83d\udc9d Become our sponsor to thank us for the time saved \ud83d\ude09","title":"Update Dependencies"},{"location":"update-dependencies/#update-dependencies","text":"The core feature is gradle refreshVersions is that it will lookup automatically for available updates for all the dependencies that it manages. This is done in three small steps:","title":"Update dependencies"},{"location":"update-dependencies/#1-run-the-refreshversions-gradle-task","text":"Run the refreshVersions gradle task on the root project: ./gradlew refreshVersions Hint: You don\u2019t need to leave the IDE to run a Gradle task. IntelliJ has a handy action named \u201cExecute Gradle Task\u201d: Gradle refreshVersions is fast: it usually takes less than 10 seconds to execute on relatively big projects.","title":"1. Run the refreshVersions Gradle task"},{"location":"update-dependencies/#2-apply-the-updates-you-want-to","text":"Open the versions.properties file. Let say you have this initial state: After you have run the refreshVersions task, you will see the available updates as comments :","title":"2. Apply the updates you want to"},{"location":"update-dependencies/#why-as-comments","text":"Looking for available updates is certainly a job best done by a computer program (instead of you doing the monkey job of googling, clicking and scrolling for every single used dependency). However, the decision of whether to upgrade or not, when, and towards which version, is best decided by the developers responsible like you.","title":"Why as comments?"},{"location":"update-dependencies/#edit-the-versionsproperties-file","text":"If you decide to update, just replace the previous version with the update: If you decide to not update for now, you can leave the comments there. They will not affect your build, and will serve as a reminder to revisit upgrading these dependencies later. They also allow you to glance at how behind the dependencies are, which is a way to estimate the technical debt of the project regarding the dependencies upgrades. If you want to delete these comments, it\u2019s possible too, and it\u2019s safe. Running the refreshVersions task will bring them back (plus any newer available update).","title":"Edit the versions.properties file"},{"location":"update-dependencies/#3-perform-a-gradle-syncreload","text":"The file versions.properties is part of the Gradle build. Consequently, after you have edited it, you need to ensure the IDE gets the changes. The action to do it have a different name depending on the IDE: IntelliJ IDEA: Run the \u201cReload all Gradle projects\u201d action (via ctrl / cmd + shift + A ), or click the refresh arrows in the Gradle tool window Android Studio: Run the \u201cSync Project with Gradle Files\u201d action (via ctrl / cmd + shift + A ), or click the elephant + arrow icon in the toolbar. At that point, you probably want to: \u23ed Migrate deprecated symbols (if any) \ud83d\udd28 Ensure the codebase still builds properly \u2705 Ensure the tests still run properly \ud83d\udd75\ufe0f\u200d\u2640\ufe0f Do manual testing if needed \u2705 Commit when appropriate \ud83d\udc9d Become our sponsor to thank us for the time saved \ud83d\ude09","title":"3. Perform a Gradle sync/reload"},{"location":"contributing/code_of_conduct/","text":"Code of Conduct \u00b6 Whenever you are about to post or commit, ask yourself \u201cWould an idiot do that?\u201d And if they would, do not do that thing. https://youtu.be/KFwUcEwD4l4 Use this Code of Conduct as you like in your own projects and organizations. Q & A \u00b6 Q: What about breathing? A: The behavior must be exclusive to idiocy.","title":"Code of Conduct"},{"location":"contributing/code_of_conduct/#code-of-conduct","text":"Whenever you are about to post or commit, ask yourself \u201cWould an idiot do that?\u201d And if they would, do not do that thing. https://youtu.be/KFwUcEwD4l4 Use this Code of Conduct as you like in your own projects and organizations.","title":"Code of Conduct"},{"location":"contributing/code_of_conduct/#q-a","text":"Q: What about breathing? A: The behavior must be exclusive to idiocy.","title":"Q &amp; A"},{"location":"contributing/dependency-notations-updates/","text":"Submitting dependency notations updates \u00b6 TK","title":"Dependency notations"},{"location":"contributing/dependency-notations-updates/#submitting-dependency-notations-updates","text":"TK","title":"Submitting dependency notations updates"},{"location":"contributing/dev-env/","text":"Dev environment for contributors \u00b6 TK Writing a Gradle plugin \u00b6 If you have never worked on a Gradle plugin before, have a glimpse at the following guides Designing Gradle plugins Implementing Gradle plugins Testing Gradle plugins https://github.com/gradle-guides/gradle-site-plugin is a wonderful Gradle plugin sample demonstrating established techniques and practices for plugin development as described in the following guides:","title":"Dev environment"},{"location":"contributing/dev-env/#dev-environment-for-contributors","text":"TK","title":"Dev environment for contributors"},{"location":"contributing/dev-env/#writing-a-gradle-plugin","text":"If you have never worked on a Gradle plugin before, have a glimpse at the following guides Designing Gradle plugins Implementing Gradle plugins Testing Gradle plugins https://github.com/gradle-guides/gradle-site-plugin is a wonderful Gradle plugin sample demonstrating established techniques and practices for plugin development as described in the following guides:","title":"Writing a Gradle plugin"},{"location":"contributing/improving-docs/","text":"Improving docs \u00b6 TK","title":"Improving docs"},{"location":"contributing/improving-docs/#improving-docs","text":"TK","title":"Improving docs"}]}